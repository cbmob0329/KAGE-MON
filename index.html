<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>ミヤネコ GBA横スクアクション（小さめ調整）</title>
<style>
  :root{ --ui-bg:#0b0e13; --ui-fg:#fff; --ui-dim:#9aa3b2; --acc:#34d3ff; }
  html,body{margin:0;height:100%;background:#000;color:#fff;touch-action:none}
  #wrap{position:fixed; inset:0; display:flex;}
  #cv{width:100%;height:100%;display:block;background:#000;touch-action:none}
  .hud{position:fixed;left:0;right:0;top:0;display:flex;gap:10px;align-items:center;
       padding:calc(env(safe-area-inset-top) + 6px) 10px 6px;pointer-events:none;
       font:14px/1.2 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  .chip{background:rgba(0,0,0,.55);border:1px solid #2b3343;padding:6px 10px;border-radius:999px;pointer-events:auto}
  .bar{height:8px;width:160px;background:#161f2a;border-radius:999px;overflow:hidden;border:1px solid #2b3343}
  .fill{height:100%;width:0%;background:linear-gradient(90deg,#35f,#3df,#9ff)}
  .controls{position:fixed;inset:auto 0 0 0;display:flex;justify-content:space-between;gap:10px;
            padding:calc(env(safe-area-inset-bottom) + 8px) 10px 10px;pointer-events:none}
  .leftpad,.rightpad{display:flex;gap:10px;pointer-events:auto}
  button.ctrl{min-width:64px;min-height:64px;border:1px solid #2a3344;background:rgba(10,12,16,.8);color:#fff;border-radius:16px}
  button.ctrl:active{transform:scale(.97)}
  .wide{min-width:84px}
  #rotate{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.9);z-index:9999;text-align:center}
  #rotate .box{padding:24px;border:1px solid #334;background:#0b0e13;border-radius:16px;color:#cfe5ff;font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  #rotate.show{display:grid}
</style>
</head>
<body>
<div id="wrap"><canvas id="cv"></canvas></div>

<div class="hud">
  <div class="chip">Miyneko Test (Small)</div>
  <div class="bar" title="UL Gauge"><div id="gfill" class="fill"></div></div>
  <div class="chip" id="state">idle</div>
</div>

<div class="controls">
  <div class="leftpad">
    <button id="left" class="ctrl wide">←</button>
    <button id="right" class="ctrl wide">→</button>
    <button id="jump" class="ctrl">JUMP</button>
  </div>
  <div class="rightpad">
    <button id="attack" class="ctrl">ATTACK</button>
    <button id="ul" class="ctrl">UL（HOLD）</button>
  </div>
</div>

<div id="rotate"><div class="box">横画面に回転してください（横固定を試みます）</div></div>

<script>
(() => {
  // ===== Canvas =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  ctx.imageSmoothingEnabled = false; // ドットくっきり

  let W=0,H=0,dpr=1;
  function fit(){
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = cv.clientWidth; H = cv.clientHeight;
    cv.width  = Math.floor(W * dpr);
    cv.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  addEventListener('resize', fit, {passive:true});
  fit();

  // ===== Orientation lock =====
  function tryLockLandscape(){
    if (screen.orientation && screen.orientation.lock){
      screen.orientation.lock('landscape').catch(()=>{});
    }
  }
  function checkOrientation(){
    const isPortrait = matchMedia('(orientation: portrait)').matches;
    document.getElementById('rotate').classList.toggle('show', isPortrait);
  }
  addEventListener('orientationchange', checkOrientation);
  checkOrientation();
  addEventListener('pointerdown', tryLockLandscape, {once:true});

  // ===== Input =====
  const keys = new Set();
  const map = { left:'Left', right:'Right', jump:'Jump', attack:'Attack', ul:'UL' };
  for (const id in map){
    const el = document.getElementById(id);
    const code = map[id];
    const down = e=>{ e.preventDefault(); keys.add(code); };
    const up   = e=>{ e.preventDefault(); keys.delete(code); };
    el.addEventListener('touchstart',down,{passive:false});
    el.addEventListener('touchend',  up,{passive:false});
    el.addEventListener('mousedown', down);
    el.addEventListener('mouseup',   up);
    el.addEventListener('mouseleave',up);
  }
  addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if(['arrowleft','a'].includes(k)) keys.add('Left');
    if(['arrowright','d'].includes(k)) keys.add('Right');
    if(['arrowup','w',' '].includes(k)) keys.add('Jump');
    if(k==='j') keys.add('Attack');
    if(k==='k') keys.add('UL');
  });
  addEventListener('keyup', e=>{
    const k = e.key.toLowerCase();
    if(['arrowleft','a'].includes(k)) keys.delete('Left');
    if(['arrowright','d'].includes(k)) keys.delete('Right');
    if(['arrowup','w',' '].includes(k)) keys.delete('Jump');
    if(k==='j') keys.delete('Attack');
    if(k==='k') keys.delete('UL');
  });

  // ===== Assets =====
  const IMGS = {};
  const files = [
    'tati.png','hasi.png','hasi3.png',
    'kou.png','kou1.png','kou2.png',
    'UL1.png','UL2.png','UL3.png','UL4.png','ULzan.png'
  ];
  awaitAll(files.map(loadImage)).then(()=>{ /* ready */ });
  function loadImage(name){
    return new Promise(res=>{
      const img = new Image();
      img.onload=()=>{ IMGS[name]=img; res(); };
      img.onerror=()=>{ IMGS[name]=null; res(); };
      img.src = name + '?v=' + Date.now();
    });
  }
  function awaitAll(ps){ return Promise.all(ps); }

  // ===== World / Scale =====
  const CONFIG = {
    playerH: 32,       // ★ 小さめ（ロックマン/マリオ感）に正規化
    gravity: 1800,
    levelW: 5000,
    runFps: 10,        // 走り2コマ
    atkFps: 6,         // ★ 攻撃2コマを少しゆっくり
    atkWindow: 0.35,
    dashChargeMax: 0.8,
    ulChargeMax: 1.8
  };
  function groundY(){ return H - Math.max(72, Math.min(120, H*0.18)); }

  // ===== Simple loop background (temp) =====
  let camX = 0;
  function drawBG(){
    const sky1 = '#0c121c', sky2 = '#0e1722';
    const bandH = 8;
    for (let y=0;y<H;y+=bandH){
      ctx.fillStyle = (Math.floor(y/bandH)%2)?sky1:sky2;
      ctx.fillRect(0,y,W,bandH);
    }
    ctx.fillStyle = '#0a111a';
    const base = H*0.6;
    const p = (camX*0.25)%W;
    ctx.beginPath();
    ctx.moveTo(-p, base+8);
    for (let x=-p; x<=W+100; x+=100){
      const h = base + Math.sin((x+p)*0.01)*16 + 10;
      ctx.lineTo(x, h);
    }
    ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath(); ctx.fill();

    const gy = groundY();
    ctx.fillStyle = '#1a2432'; ctx.fillRect(0, gy, W, H-gy);
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    for (let x = -((camX|0)%32); x < W; x+=32){
      ctx.beginPath(); ctx.moveTo(x,gy); ctx.lineTo(x,H); ctx.stroke();
    }
    for (let y = gy; y < H; y+=16){
      ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke();
    }
  }

  // ===== Projectiles =====
  const projectiles = [];
  function spawnULZan(actor, dir){
    const img = IMGS['ULzan.png'];
    const scale = actor.scale;
    const w = img ? Math.round(img.width * scale) : 28;
    const h = img ? Math.round(img.height* scale) : 10;
    projectiles.push({
      x: actor.x + actor.w/2 + dir*8,
      y: groundY() - h + 2,
      vx: 1100*dir,
      life: 3,
      w, h, sprite:'ULzan.png'
    });
  }

  // ===== Actor =====
  class Actor{
    constructor(){
      this.x=300; this.y=0; this.vx=0; this.vy=0;
      this.dir=-1; // 左向きが基本（右へ進む時に反転）
      this.onGround=false;

      this.runFrames=['hasi.png','hasi3.png'];

      // 攻撃
      this.comboStep=0; this.comboWindow=0;
      this.atkPlaying=false; this.atkFrameT=0;
      this.dashCharging=false; this.dashCharge=0;
      this.dashInMotion=false; this.dashT=0; this.moveLock=0;

      // 必殺
      this.ulCharging=false; this.ulCharge=0; this.ulMaxBlink=false;
      this.ulReleasing=false; this.ulLockT=0;

      // スケール：立ち絵高さ→32px
      const base = IMGS['tati.png'];
      const h = base ? base.height : 64;
      this.scale = CONFIG.playerH / h;
      this.w = base ? Math.round(base.width * this.scale) : 20;
      this.h = base ? Math.round(base.height* this.scale) : CONFIG.playerH;

      // 挙動（小さいので速度は少し控えめに）
      this.moveSpeed = 300;
      this.maxVX = 480;
      this.jumpV = 620;

      this.animT=0;
    }

    currentSprite(){
      if (this.ulReleasing) return 'UL4.png';
      if (this.ulCharging){
        const seq = ['UL1.png','UL2.png','UL3.png'];
        return seq[Math.floor(this.animT*10)%seq.length];
      }
      if (this.atkPlaying){
        if (this.comboStep===1){
          const idx = Math.min(1, Math.floor(this.atkFrameT*CONFIG.atkFps));
          return ['kou.png','kou1.png'][idx];
        } else if (this.comboStep===2){
          if (this.dashCharging) return 'kou.png';
          const idx = Math.min(1, Math.floor(this.atkFrameT*CONFIG.atkFps));
          return ['kou.png','kou2.png'][idx];
        }
      }
      if (!this.onGround) return 'tati.png';
      const moving = Math.abs(this.vx)>20;
      if (moving){
        const f = Math.floor(this.animT*CONFIG.runFps) % this.runFrames.length;
        return this.runFrames[f];
      }
      return 'tati.png';
    }

    draw(shake=0){
      const name = this.currentSprite();
      const img = IMGS[name];
      const dw = img ? Math.round(img.width * this.scale) : this.w;
      const dh = img ? Math.round(img.height* this.scale) : this.h;
      this.w = dw; this.h = dh;
      const dx = Math.round(this.x + shake);
      const dy = Math.round(this.y + shake);
      ctx.save();
      // ★右へ進むときは反転（スプライトは左向き前提）
      if (this.dir > 0){
        ctx.translate(dx + dw, dy);
        ctx.scale(-1,1);
        if (img) ctx.drawImage(img, 0, 0, dw, dh); else { ctx.fillStyle='#fff'; ctx.fillRect(0,0,dw,dh); }
      } else {
        if (img) ctx.drawImage(img, dx, dy, dw, dh); else { ctx.fillStyle='#fff'; ctx.fillRect(dx,dy,dw,dh); }
      }
      ctx.restore();

      // プレイヤーの頭上ゲージ
      if (this===player && (this.ulCharging || this.ulReleasing)){
        const g = this.ulCharging ? (this.ulCharge/CONFIG.ulChargeMax) : 0;
        const bw = 60, bh=6;
        const gx = this.x + this.w/2 - bw/2;
        const gy = this.y - 14;
        ctx.fillStyle='rgba(0,0,0,0.65)'; ctx.fillRect(gx-2, gy-2, bw+4, bh+4);
        ctx.fillStyle='#203040'; ctx.fillRect(gx, gy, bw, bh);
        ctx.fillStyle = this.ulMaxBlink ? (Math.random()<0.5?'#8ff':'#fff') : '#7cf';
        ctx.fillRect(gx, gy, bw*Math.min(1,g), bh);
        ctx.strokeStyle='#5aa7ff'; ctx.strokeRect(gx, gy, bw, bh);
      }
    }
  }

  const player = new Actor();
  const stateLabel = document.getElementById('state');
  const gfill = document.getElementById('gfill');

  // ===== Helpers =====
  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }

  // ===== Attack / UL =====
  let prevAtk=false, prevUL=false;

  function handleAttack(a, dt){
    const nowAtk = keys.has('Attack');
    if (a.comboWindow>0) a.comboWindow -= dt;

    if (a.dashInMotion){
      a.dashT -= dt;
      if (a.dashT<=0){
        a.dashInMotion=false;
        a.atkPlaying=false;
        a.comboStep=0; // 攻撃後は立ち絵に戻る
      }
    }

    if (nowAtk && !prevAtk && !a.ulCharging && !a.ulReleasing){
      if (a.comboStep===0){
        startAttack1(a);
      } else if (a.comboStep===1 && a.comboWindow>0){
        startAttack2Prepare(a);
      }
    }
    if (!nowAtk && prevAtk){
      if (a.comboStep===2 && a.dashCharging) releaseAttack2Dash(a);
    }
    prevAtk = nowAtk;

    if (a.comboStep===2 && a.dashCharging){
      a.dashCharge = clamp(a.dashCharge + dt, 0, CONFIG.dashChargeMax);
      a.vx *= 0.985;
    }

    if (a.atkPlaying) a.atkFrameT += dt;
  }

  function startAttack1(a){
    a.atkPlaying = true;
    a.comboStep = 1;
    a.atkFrameT = 0;
    a.comboWindow = CONFIG.atkWindow;
    a.moveLock = 0.08;
    // 1段目は短く、終わったら立ち絵へ
    setTimeout(()=>{ if(a.comboStep===1 && !a.dashCharging){ a.atkPlaying=false; a.comboStep=0; } }, 180);
  }

  function startAttack2Prepare(a){
    a.atkPlaying = true;
    a.comboStep = 2;
    a.atkFrameT = 0;
    a.dashCharging = true;
    a.dashCharge = 0;
    a.moveLock = 0.12;
  }

  function releaseAttack2Dash(a){
    a.dashCharging = false;
    a.dashInMotion = true;
    const r = clamp(a.dashCharge/CONFIG.dashChargeMax, 0, 1);
    const dashDist = 90 + r*200;  // 小さめキャラに合わせて調整
    const dashDur  = 0.16 + r*0.12;
    a.dashT = dashDur;
    const sign = (a.dir>0)? +1 : -1;
    const targetX = clamp(a.x + sign*dashDist, 0, CONFIG.levelW - a.w);
    const need = targetX - a.x;
    a.vx = need / dashDur;
    a.atkFrameT = 0; // kou2表示
    // 終了後は上のdashInMotion処理で立ちへ戻る
  }

  function handleUL(a, dt){
    const nowUL = keys.has('UL');
    if (nowUL && !a.ulReleasing){
      a.ulCharging = true;
      a.ulCharge = clamp(a.ulCharge + dt, 0, CONFIG.ulChargeMax);
      a.ulMaxBlink = (a.ulCharge>=CONFIG.ulChargeMax);
      a.atkPlaying=false; a.comboStep=0; a.dashCharging=false; a.dashInMotion=false;
    }
    if (!nowUL && prevUL){
      if (a.ulCharging && !a.ulReleasing) fireUL(a);
      a.ulCharging=false; a.ulCharge=0; a.ulMaxBlink=false;
    }
    prevUL = nowUL;

    if (a.ulReleasing){
      a.ulLockT -= dt;
      if (a.ulLockT<=0) a.ulReleasing=false;
    }

    // HUD
    if (a===player){
      const g = a.ulCharging ? (a.ulCharge/CONFIG.ulChargeMax) : 0;
      gfill.style.width = Math.round(Math.min(1,g)*100)+'%';
    }
  }

  function fireUL(a){
    a.ulReleasing = true;
    a.ulLockT = 2.0;
    spawnULZan(a, -1);
    spawnULZan(a, +1);
  }

  // ===== Loop =====
  let last = performance.now();
  requestAnimationFrame(loop);
  function loop(t){
    const dt = Math.min(0.033, (t-last)/1000); last=t;
    update(dt); render();
    requestAnimationFrame(loop);
  }

  function update(dt){
    const canControl = !player.ulReleasing && player.moveLock<=0;
    if (canControl){
      if (keys.has('Left')){ player.vx -= player.moveSpeed*2*dt; player.dir = -1; }
      if (keys.has('Right')){ player.vx += player.moveSpeed*2*dt; player.dir = +1; }
      if (keys.has('Jump') && player.onGround){ player.vy = -player.jumpV; }
    }

    if (player.onGround && !(keys.has('Left')||keys.has('Right'))){
      const s = Math.sign(player.vx);
      const m = Math.min(Math.abs(player.vx), 1400*dt);
      player.vx -= s*m;
    }
    player.vx = clamp(player.vx, -player.maxVX, player.maxVX);

    player.vy += CONFIG.gravity*dt;
    player.x  += player.vx*dt;
    player.y  += player.vy*dt;

    const gy = groundY();
    if (player.y + player.h > gy){ player.y = gy - player.h; player.vy=0; player.onGround=true; }
    else player.onGround=false;

    if (player.x < 0){ player.x=0; player.vx=0; }
    if (player.x + player.w > CONFIG.levelW){ player.x = CONFIG.levelW - player.w; player.vx=0; }

    handleAttack(player, dt);
    handleUL(player, dt);

    camX = clamp(player.x + player.w*0.5 - W*0.45, 0, CONFIG.levelW - W);

    const st = player.ulReleasing ? 'UL4中'
             : player.ulCharging ? 'UL溜め'
             : player.atkPlaying ? (player.comboStep===1?'攻撃1':'攻撃2')
             : (!player.onGround?'空中':(Math.abs(player.vx)>20?'移動':'待機'));
    document.getElementById('state').textContent = st;
  }

  function render(){
    drawBG();

    ctx.save();
    ctx.translate(-camX, 0);

    // 弾
    for (let i=projectiles.length-1;i>=0;i--){
      const p = projectiles[i];
      p.x += p.vx * (1/60);
      p.y  = groundY() - p.h + 2;
      p.life -= (1/60);
      const img = IMGS[p.sprite];
      if (img) ctx.drawImage(img, Math.round(p.x), Math.round(p.y), p.w, p.h);
      else { ctx.fillStyle='#7cf'; ctx.fillRect(p.x, p.y, p.w, p.h); }
      if (p.x<-200 || p.x>CONFIG.levelW+200 || p.life<=0) projectiles.splice(i,1);
    }

    // プレイヤー（UL4中は微振動）
    const shake = player.ulReleasing ? (Math.random()*2-1)*2 : 0;
    player.draw(shake);

    ctx.restore();
  }
})();
</script>
</body>
</html>
