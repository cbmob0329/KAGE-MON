<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>ミヤネコ GBAドット（極小＆連撃修正）</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;touch-action:none}
  #cv{width:100%;height:100%;display:block;background:#000;touch-action:none}
  .hud{position:fixed;left:0;right:0;top:0;display:flex;gap:10px;align-items:center;
       padding:calc(env(safe-area-inset-top) + 6px) 10px 6px;pointer-events:none;
       font:14px/1.2 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  .chip{background:rgba(0,0,0,.55);border:1px solid #2b3343;padding:6px 10px;border-radius:999px;pointer-events:auto}
  .bar{height:8px;width:160px;background:#161f2a;border-radius:999px;overflow:hidden;border:1px solid #2b3343}
  .fill{height:100%;width:0%;background:linear-gradient(90deg,#35f,#3df,#9ff)}
  .controls{position:fixed;inset:auto 0 0 0;display:flex;justify-content:space-between;gap:10px;
            padding:calc(env(safe-area-inset-bottom) + 8px) 10px 10px;pointer-events:none}
  .leftpad,.rightpad{display:flex;gap:10px;pointer-events:auto}
  button.ctrl{min-width:64px;min-height:64px;border:1px solid #2a3344;background:rgba(10,12,16,.8);color:#fff;border-radius:16px}
  button.ctrl:active{transform:scale(.97)}
  #rotate{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.9);z-index:9999;text-align:center}
  #rotate .box{padding:24px;border:1px solid #334;background:#0b0e13;border-radius:16px;color:#cfe5ff;font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  #rotate.show{display:grid}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div class="hud">
  <div class="chip">Miyneko (H=10px, aspect kept)</div>
  <div class="bar" title="UL Gauge"><div id="gfill" class="fill"></div></div>
  <div class="chip" id="state">idle</div>
</div>

<div class="controls">
  <div class="leftpad">
    <button id="left"   class="ctrl">←</button>
    <button id="right"  class="ctrl">→</button>
    <button id="jump"   class="ctrl">JUMP</button>
  </div>
  <div class="rightpad">
    <button id="attack" class="ctrl">ATTACK</button>
    <button id="ul"     class="ctrl">UL（HOLD）</button>
  </div>
</div>

<div id="rotate"><div class="box">横画面に回転してください（横固定を試みます）</div></div>

<script>
(() => {
  // ===== Canvas / pixel settings =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  ctx.imageSmoothingEnabled = false; // ドット絵の縦横比を保ったままクッキリ表示
  let W=0,H=0,dpr=1;
  function fit(){
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = cv.clientWidth; H = cv.clientHeight;
    cv.width  = Math.floor(W * dpr);
    cv.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // 等倍スケールのみ（非等倍は禁止）
    ctx.imageSmoothingEnabled = false;
  }
  addEventListener('resize', fit, {passive:true}); fit();

  // ===== Orientation lock =====
  function tryLockLandscape(){ if (screen.orientation?.lock){ screen.orientation.lock('landscape').catch(()=>{}); } }
  function checkOrientation(){ const p = matchMedia('(orientation: portrait)').matches; document.getElementById('rotate').classList.toggle('show', p); }
  addEventListener('orientationchange', checkOrientation); checkOrientation();
  addEventListener('pointerdown', tryLockLandscape, {once:true});

  // ===== Input =====
  const keys = new Set();
  const map = { left:'Left', right:'Right', jump:'Jump', attack:'Attack', ul:'UL' };
  for (const id in map){
    const el = document.getElementById(id); const code = map[id];
    const down = e=>{ e.preventDefault(); keys.add(code); };
    const up   = e=>{ e.preventDefault(); keys.delete(code); };
    el.addEventListener('touchstart',down,{passive:false});
    el.addEventListener('touchend',  up,{passive:false});
    el.addEventListener('mousedown', down);
    el.addEventListener('mouseup',   up);
    el.addEventListener('mouseleave',up);
  }
  addEventListener('keydown', e=>{
    const k=e.key.toLowerCase();
    if(['arrowleft','a'].includes(k)) keys.add('Left');
    if(['arrowright','d'].includes(k)) keys.add('Right');
    if(['arrowup','w',' '].includes(k)) keys.add('Jump');
    if(k==='j') keys.add('Attack');
    if(k==='k') keys.add('UL');
  });
  addEventListener('keyup', e=>{
    const k=e.key.toLowerCase();
    if(['arrowleft','a'].includes(k)) keys.delete('Left');
    if(['arrowright','d'].includes(k)) keys.delete('Right');
    if(['arrowup','w',' '].includes(k)) keys.delete('Jump');
    if(k==='j') keys.delete('Attack');
    if(k==='k') keys.delete('UL');
  });

  // ===== Assets =====
  const IMGS = {};
  const files = ['tati.png','hasi.png','hasi3.png','kou.png','kou1.png','kou2.png','UL1.png','UL2.png','UL3.png','UL4.png','ULzan.png'];
  Promise.all(files.map(n=>new Promise(res=>{ const i=new Image(); i.onload=()=>{IMGS[n]=i;res();}; i.onerror=()=>{IMGS[n]=null;res();}; i.src=n+'?v='+Date.now(); })))
    .then(()=>{ /* ready */ });

  // ===== World / Config =====
  const CONFIG = {
    playerH: 10,     // ★ 極小サイズ（高さ10px）※縦横比は元画像の比率を維持
    gravity: 1800,
    levelW: 5000,
    runFps: 10,      // hasi/hasi3 の2コマ
    // 攻撃表示（必ず攻撃1を出し切る）
    atk1Windup: 0.14, // kou（構え）表示
    atk1Hit:    0.24, // kou1（攻撃1ヒット）表示
    atk2Windup: 0.14, // kou（構え）※2段目の溜め中は押してる間ずっとkou
    atk2Hit:    0.28, // kou2（攻撃2ヒット）表示（突進中は別途）
    atkWindow:  0.35, // 攻撃1の最中に2を予約できる時間
    dashChargeMax: 0.8,
    ulChargeMax:   1.8
  };
  const gfill = document.getElementById('gfill');
  const stateLabel = document.getElementById('state');
  function groundY(){ return H - Math.max(64, Math.min(104, H*0.15)); }

  // ===== Temp background (loop ground) =====
  let camX = 0;
  function drawBG(){
    // 空
    const bandH=8; for(let y=0;y<H;y+=bandH){ ctx.fillStyle=(Math.floor(y/bandH)%2)?'#0c121c':'#0e1722'; ctx.fillRect(0,y,W,bandH); }
    // 奥
    ctx.fillStyle='#0a111a'; const base=H*0.6, p=(camX*0.25)%W;
    ctx.beginPath(); ctx.moveTo(-p,base+8);
    for(let x=-p;x<=W+100;x+=100){ const h=base+Math.sin((x+p)*0.01)*16+10; ctx.lineTo(x,h); }
    ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath(); ctx.fill();
    // 地面
    const gy=groundY(); ctx.fillStyle='#1a2432'; ctx.fillRect(0,gy,W,H-gy);
    ctx.strokeStyle='rgba(255,255,255,0.05)';
    for(let x=-((camX|0)%32);x<W;x+=32){ ctx.beginPath(); ctx.moveTo(x,gy); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=gy;y<H;y+=16){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke(); }
  }

  // ===== Projectiles =====
  const projectiles=[];
  function spawnULZan(actor,dir){
    const img=IMGS['ULzan.png']; const sc=actor.scale;
    const w=img?Math.round(img.width*sc):8, h=img?Math.round(img.height*sc):3;
    projectiles.push({ x:actor.x+actor.w/2+dir*5, y:groundY()-h+1, vx:1100*dir, life:3, w, h, sprite:'ULzan.png' });
  }

  // ===== Actor =====
  class Actor{
    constructor(){
      this.x=300; this.y=0; this.vx=0; this.vy=0;
      this.dir=-1; // 左向き前提。右へ進む時は反転描画
      this.onGround=false;
      this.runFrames=['hasi.png','hasi3.png'];

      // 攻撃
      this.comboStep=0;          // 0:なし / 1:攻撃1中 / 2:攻撃2段階
      this.atkTime=0;
      this.atkPlaying=false;
      this.comboWindow=0;
      this.queueSecond=false;    // ★ 攻撃2予約（攻撃1を出し切ってから開始）
      this.dashCharging=false;   // 攻撃2の溜め
      this.dashCharge=0;
      this.dashInMotion=false;   // 攻撃2の突進中
      this.dashT=0;

      // 必殺
      this.ulCharging=false; this.ulCharge=0; this.ulMaxBlink=false;
      this.ulReleasing=false; this.ulLockT=0;

      // スケール（縦横比を厳守）
      const base=IMGS['tati.png']; const origH= base? base.height : 40;
      this.scale = CONFIG.playerH / origH; // 縦方向基準の等倍スケール
      this.w = base? Math.round(base.width * this.scale) : 6;
      this.h = base? Math.round(base.height* this.scale) : CONFIG.playerH;

      // 挙動
      this.moveSpeed=250; this.maxVX=400; this.jumpV=540;
      this.animT=0;
    }

    sprite(){
      if (this.ulReleasing) return 'UL4.png';
      if (this.ulCharging){
        const s=['UL1.png','UL2.png','UL3.png']; return s[Math.floor(this.animT*10)%s.length];
      }
      if (this.atkPlaying){
        if (this.comboStep===1){
          return (this.atkTime < CONFIG.atk1Windup) ? 'kou.png' : 'kou1.png';
        }
        if (this.comboStep===2){
          // 溜め中は常に kou、突進に移った直後〜一定時間は kou2 を見せる
          if (this.dashCharging) return 'kou.png';
          return 'kou2.png';
        }
      }
      if (!this.onGround) return 'tati.png';
      const moving = Math.abs(this.vx)>4;
      if (moving){ const f=Math.floor(this.animT*CONFIG.runFps)%this.runFrames.length; return this.runFrames[f]; }
      return 'tati.png';
    }

    draw(shake=0){
      const name=this.sprite(); const img=IMGS[name];
      const dw=img? Math.round(img.width * this.scale) : this.w;
      const dh=img? Math.round(img.height* this.scale): this.h;
      this.w=dw; this.h=dh; const dx=Math.round(this.x+shake), dy=Math.round(this.y+shake);
      ctx.save();
      if (this.dir>0){ ctx.translate(dx+dw,dy); ctx.scale(-1,1); img? ctx.drawImage(img,0,0,dw,dh): (ctx.fillStyle='#fff', ctx.fillRect(0,0,dw,dh)); }
      else { img? ctx.drawImage(img,dx,dy,dw,dh): (ctx.fillStyle='#fff', ctx.fillRect(dx,dy,dw,dh)); }
      ctx.restore();

      // 頭上ゲージ（必殺）
      if (this===player && (this.ulCharging || this.ulReleasing)){
        const g = this.ulCharging ? (this.ulCharge/CONFIG.ulChargeMax) : 0;
        const bw=44, bh=4, gx=this.x+this.w/2-bw/2, gy=this.y-10;
        ctx.fillStyle='rgba(0,0,0,0.65)'; ctx.fillRect(gx-2,gy-2,bw+4,bh+4);
        ctx.fillStyle='#203040'; ctx.fillRect(gx,gy,bw,bh);
        ctx.fillStyle = this.ulMaxBlink ? (Math.random()<0.5?'#8ff':'#fff') : '#7cf';
        ctx.fillRect(gx,gy,bw*Math.min(1,g),bh);
        ctx.strokeStyle='#5aa7ff'; ctx.strokeRect(gx,gy,bw,bh);
      }
    }
  }

  const player=new Actor();

  // ===== Helpers =====
  const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
  let prevAtk=false, prevUL=false;

  // ===== Attack flow (必ず攻撃1を完遂してから2へ) =====
  function attackUpdate(a,dt){
    const nowAtk = keys.has('Attack');

    // 予約受付（攻撃1中のみ）
    if (nowAtk && !prevAtk && a.comboStep===1 && a.comboWindow>0){
      a.queueSecond = true; // ここでは開始しない
    }
    // 攻撃ボタン押下で開始
    if (nowAtk && !prevAtk && a.comboStep===0 && !a.ulCharging && !a.ulReleasing){
      startAttack1(a);
    }
    // 2段目：溜め→離しで突進
    if (!nowAtk && prevAtk && a.comboStep===2 && a.dashCharging){
      releaseAttack2Dash(a);
    }
    prevAtk = nowAtk;

    // 2段目：溜め中
    if (a.comboStep===2 && a.dashCharging){
      a.dashCharge = clamp(a.dashCharge + dt, 0, CONFIG.dashChargeMax);
      a.vx *= 0.995;
    }
    // 2段目：突進中
    if (a.dashInMotion){
      a.dashT -= dt;
      if (a.dashT<=0){
        a.dashInMotion=false; a.atkPlaying=false; a.comboStep=0;
      }
    }

    // 攻撃タイムライン
    if (a.atkPlaying){
      a.atkTime += dt;
      if (a.comboStep===1){
        const total = CONFIG.atk1Windup + CONFIG.atk1Hit;
        // 攻撃1を出し切る
        if (a.atkTime >= total){
          if (a.queueSecond){ // ★出し切った後に2段目へ
            startAttack2Prepare(a);
          } else {
            a.atkPlaying=false; a.comboStep=0;
          }
        }
      }
      // 攻撃2は dashInMotion の終了で復帰
    }
  }

  function startAttack1(a){
    a.atkPlaying=true; a.comboStep=1; a.atkTime=0; a.comboWindow=CONFIG.atkWindow; a.queueSecond=false;
  }
  function startAttack2Prepare(a){
    a.atkPlaying=true; a.comboStep=2; a.atkTime=0; a.queueSecond=false;
    a.dashCharging=true; a.dashCharge=0;
  }
  function releaseAttack2Dash(a){
    a.dashCharging=false; a.dashInMotion=true; a.atkTime=0;
    const r=clamp(a.dashCharge/CONFIG.dashChargeMax,0,1);
    const dashDist=80 + r*180, dashDur=0.16 + r*0.12;
    a.dashT=dashDur; const sign=(a.dir>0)?+1:-1;
    const targetX=clamp(a.x + sign*dashDist, 0, CONFIG.levelW - a.w);
    const need=targetX - a.x; a.vx = need / dashDur;
  }

  // ===== UL handling =====
  function ulUpdate(a,dt){
    const nowUL = keys.has('UL');
    if (nowUL && !a.ulReleasing){
      a.ulCharging=true; a.ulCharge = clamp(a.ulCharge + dt, 0, CONFIG.ulChargeMax);
      a.ulMaxBlink = (a.ulCharge>=CONFIG.ulChargeMax);
      // 溜め優先（攻撃は解除）
      a.atkPlaying=false; a.comboStep=0; a.queueSecond=false; a.dashCharging=false; a.dashInMotion=false;
    }
    if (!nowUL && prevUL){
      if (a.ulCharging && !a.ulReleasing) fireUL(a);
      a.ulCharging=false; a.ulCharge=0; a.ulMaxBlink=false;
    }
    prevUL = nowUL;

    if (a.ulReleasing){
      a.ulLockT -= dt;
      if (a.ulLockT<=0) a.ulReleasing=false;
    }
    // HUD
    const g = a.ulCharging ? (a.ulCharge/CONFIG.ulChargeMax) : 0;
    gfill.style.width = Math.round(Math.min(1,g)*100)+'%';
  }
  function fireUL(a){
    a.ulReleasing=true; a.ulLockT=2.0;
    spawnULZan(a,-1); spawnULZan(a,+1);
  }

  // ===== Loop =====
  let last=performance.now(); requestAnimationFrame(loop);
  function loop(t){
    const dt=Math.min(0.033,(t-last)/1000); last=t;
    update(dt); render(); requestAnimationFrame(loop);
  }

  function update(dt){
    // UL4中だけ操作不可。攻撃中も移動OK
    const canControl=!player.ulReleasing;
    if (canControl){
      if (keys.has('Left'))  { player.vx -= player.moveSpeed*2*dt; player.dir=-1; }
      if (keys.has('Right')) { player.vx += player.moveSpeed*2*dt; player.dir=+1; }
      if (keys.has('Jump') && player.onGround){ player.vy = -player.jumpV; }
    }

    // 摩擦
    if (player.onGround && !(keys.has('Left')||keys.has('Right'))){
      const s=Math.sign(player.vx); const m=Math.min(Math.abs(player.vx),1200*dt); player.vx -= s*m;
    }
    player.vx = clamp(player.vx, -player.maxVX, player.maxVX);

    // 物理
    player.vy += CONFIG.gravity*dt; player.x += player.vx*dt; player.y += player.vy*dt;

    const gy=groundY();
    if (player.y + player.h > gy){ player.y = gy - player.h; player.vy=0; player.onGround=true; } else player.onGround=false;

    if (player.x < 0){ player.x=0; player.vx=0; }
    if (player.x + player.w > CONFIG.levelW){ player.x = CONFIG.levelW - player.w; player.vx=0; }

    // 攻撃/必殺
    attackUpdate(player,dt);
    ulUpdate(player,dt);

    // カメラ
    camX = clamp(player.x + player.w*0.5 - W*0.45, 0, CONFIG.levelW - W);

    // 弾
    for (let i=projectiles.length-1;i>=0;i--){
      const p=projectiles[i];
      p.x += p.vx * (1/60); p.y = groundY()-p.h+1; p.life -= (1/60);
      if (p.x<-200 || p.x>CONFIG.levelW+200 || p.life<=0) projectiles.splice(i,1);
    }

    // 状態表示
    const st = player.ulReleasing ? 'UL4中'
             : player.ulCharging ? 'UL溜め'
             : player.atkPlaying ? (player.comboStep===1?'攻撃1（kou→kou1）':'攻撃2（kou→kou2）')
             : (!player.onGround?'空中':(Math.abs(player.vx)>4?'移動':'待機'));
    stateLabel.textContent = st;
  }

  function render(){
    drawBG();
    ctx.save(); ctx.translate(-camX,0);
    const shake = player.ulReleasing ? (Math.random()*2-1)*1 : 0;
    player.draw(shake);
    // 弾
    for (const p of projectiles){
      const img=IMGS[p.sprite];
      if (img) ctx.drawImage(img, Math.round(p.x), Math.round(p.y), p.w, p.h);
      else { ctx.fillStyle='#7cf'; ctx.fillRect(p.x,p.y,p.w,p.h); }
    }
    ctx.restore();
  }
})();
</script>
</body>
</html>
