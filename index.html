<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>ミヤネコ 横スクロール・最適化テスト</title>
<style>
  :root{
    --ui-bg:#0b0e13; --ui-fg:#fff; --ui-dim:#9aa3b2; --accent:#36d1ff;
    --btn:#141922; --btn2:#1d2531;
  }
  html,body{margin:0;height:100%;background:#000;color:#fff;touch-action:none}
  #wrap{position:fixed; inset:0; display:flex;}
  #cv{width:100%;height:100%;display:block;background:#000;touch-action:none}
  /* HUD */
  .hud{position:fixed;left:0;right:0;top:0;display:flex;gap:10px;align-items:center;
       padding:calc(env(safe-area-inset-top) + 6px) 10px 6px;pointer-events:none;
       font:14px/1.2 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  .chip{background:rgba(0,0,0,.55);border:1px solid #2b3343;padding:6px 10px;border-radius:999px;pointer-events:auto}
  .bar{height:8px;width:160px;background:#161f2a;border-radius:999px;overflow:hidden;border:1px solid #2b3343}
  .fill{height:100%;width:0%;background:linear-gradient(90deg,#35f,#3df,#9ff)}
  /* Controls */
  .controls{position:fixed;inset:auto 0 0 0;display:flex;justify-content:space-between;gap:10px;
            padding:calc(env(safe-area-inset-bottom) + 8px) 10px 10px;pointer-events:none}
  .leftpad,.rightpad{display:flex;gap:10px;pointer-events:auto}
  button.ctrl{min-width:64px;min-height:64px;border:1px solid #2a3344;background:rgba(10,12,16,.8);color:#fff;border-radius:16px}
  button.ctrl:active{transform:scale(.97)}
  .wide{min-width:84px}
  /* Orientation overlay */
  #rotate{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.9);z-index:9999;text-align:center}
  #rotate .box{padding:24px;border:1px solid #334;background:#0b0e13;border-radius:16px;color:#cfe5ff;font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  #rotate.show{display:grid}
</style>
</head>
<body>
<div id="wrap"><canvas id="cv"></canvas></div>

<div class="hud">
  <div class="chip">Miyneko Test (Optimized)</div>
  <div class="bar" title="UL Gauge"><div id="gfill" class="fill"></div></div>
  <div class="chip" id="info">0 NPCs</div>
</div>

<div class="controls">
  <div class="leftpad">
    <button id="left" class="ctrl wide">←</button>
    <button id="right" class="ctrl wide">→</button>
    <button id="jump" class="ctrl">JUMP</button>
  </div>
  <div class="rightpad">
    <button id="attack" class="ctrl">ATTACK</button>
    <button id="ul" class="ctrl">UL（HOLD）</button>
  </div>
</div>

<div id="rotate"><div class="box">
  横画面に回転してください（横固定を試みます）
</div></div>

<script>
(() => {
  // ====== Canvas / Pixel-Perfect ======
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  // ピクセルアート最適化
  ctx.imageSmoothingEnabled = false;

  let W=0,H=0,dpr=1;
  function fit(){
    // DPRを上げすぎるとスマホで重いので上限2
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = cv.clientWidth; H = cv.clientHeight;
    cv.width  = Math.floor(W * dpr);
    cv.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', fit, {passive:true});
  fit();

  // ====== Orientation Lock（ベストエフォート） ======
  function tryLockLandscape(){
    if (screen.orientation && screen.orientation.lock) {
      screen.orientation.lock('landscape').catch(()=>{});
    }
  }
  function checkOrientation(){
    const isPortrait = window.matchMedia('(orientation: portrait)').matches;
    document.getElementById('rotate').classList.toggle('show', isPortrait);
  }
  window.addEventListener('orientationchange', checkOrientation);
  checkOrientation();
  window.addEventListener('pointerdown', tryLockLandscape, {once:true});

  // ====== Controls / Input ======
  const keys = new Set();
  const mapBtn = {
    left: 'Left', right:'Right', jump:'Jump', attack:'Attack', ul:'UL'
  };
  for (const id of Object.keys(mapBtn)){
    const el = document.getElementById(id);
    const code = mapBtn[id];
    const down = e => { e.preventDefault(); keys.add(code); };
    const up   = e => { e.preventDefault(); keys.delete(code); };
    el.addEventListener('touchstart', down, {passive:false});
    el.addEventListener('touchend',   up,   {passive:false});
    el.addEventListener('mousedown',  down);
    el.addEventListener('mouseup',    up);
    el.addEventListener('mouseleave', up);
  }
  window.addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if(['arrowleft','a'].includes(k)) keys.add('Left');
    if(['arrowright','d'].includes(k)) keys.add('Right');
    if(['arrowup','w',' '].includes(k)) keys.add('Jump');
    if(k==='j') keys.add('Attack');
    if(k==='k') keys.add('UL');
  });
  window.addEventListener('keyup', e=>{
    const k = e.key.toLowerCase();
    if(['arrowleft','a'].includes(k)) keys.delete('Left');
    if(['arrowright','d'].includes(k)) keys.delete('Right');
    if(['arrowup','w',' '].includes(k)) keys.delete('Jump');
    if(k==='j') keys.delete('Attack');
    if(k==='k') keys.delete('UL');
  });

  // ====== Assets ======
  const IMGS = {};
  const toLoad = [
    'tati.png','hasi.png','hasi2.png','hasi3.png','hasi4.png',
    'kou.png','kou1.png','kou2.png',
    'UL1.png','UL2.png','UL3.png','UL4.png','ULzan.png',
    'st.png'
  ];
  const loaded = [];
  function loadImage(name){
    return new Promise(res=>{
      const img = new Image();
      img.onload = ()=>{ IMGS[name]=img; loaded.push(name); res(); };
      img.onerror = ()=>{ IMGS[name]=null; res(); };
      img.src = name + '?v=' + Date.now();
    });
  }
  Promise.all(toLoad.map(loadImage)).then(()=> { /* ready */ });

  // ====== CONFIG: 一貫スケール ======
  const CONFIG = {
    playerLogicalH: 64, // ロックマン級：キャラ高さ64pxに正規化
    gravity: 1800,
    levelW: 6000,       // ステージ長
    groundRatio: 0.18,  // 画面下からの地面の厚み比率
    runAnimFps: 12,
    atkWindow: 0.35,
    dashChargeMax: 0.8,
    ulChargeMax: 1.8,
    maxNPC: 11          // プレイヤー+11=合計12体まで
  };
  const info = document.getElementById('info');
  const gfill = document.getElementById('gfill');

  function groundY(){ return H - Math.max(96, Math.min(160, H*CONFIG.groundRatio)); }

  // ====== Background ======
  let camX = 0;
  function drawBackground(){
    ctx.fillStyle = '#06090f';
    ctx.fillRect(0,0,W,H);
    const bg = IMGS['st.png'];
    if (!bg){
      // 簡易地面
      ctx.fillStyle = '#0e1620'; ctx.fillRect(0, groundY(), W, H-groundY());
      return;
    }
    // 背景は高さ基準で拡大：ピクセル比維持＋最近傍
    const scale = H / bg.height;
    const tileW = Math.floor(bg.width * scale);
    const tileH = Math.floor(bg.height * scale);
    const parallax = 0.3;
    let startX = -Math.floor((camX*parallax) % tileW);
    for (let x=startX - tileW; x < W + tileW; x+=tileW){
      ctx.drawImage(bg, x, 0, tileW, tileH);
    }
    // 地面強調
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(0, groundY(), W, H-groundY());
  }

  // ====== Entity（共通ロジック） ======
  class Actor {
    constructor(isPlayer=false, x=300){
      this.isPlayer = isPlayer;
      this.x = x;
      this.y = 0;
      this.vx = 0;
      this.vy = 0;
      this.dir = 1; // 右向きが正
      this.onGround = false;
      // 画像・アニメ
      this.animT = 0;
      this.runFrames = ['hasi.png','hasi2.png','hasi3.png','hasi4.png'];
      // 攻撃
      this.comboStep = 0;
      this.comboWindow = 0;
      this.atkPlaying = false;
      this.atkFrameT = 0;
      this.atk1 = ['kou.png','kou1.png'];
      this.atk2 = ['kou.png','kou2.png'];
      this.dashCharging = false;
      this.dashCharge = 0;
      this.dashInMotion = false;
      this.dashT = 0;
      this.moveLock = 0;
      // UL
      this.ulCharging = false;
      this.ulCharge = 0;
      this.ulMaxBlink = false;
      this.ulReleasing = false;
      this.ulLockT = 0;
      // 表示サイズ（初期は立ち絵から）
      const baseImg = IMGS['tati.png'];
      const h = baseImg ? baseImg.height : 80;
      const scale = CONFIG.playerLogicalH / h;
      this.scale = scale;         // スプライト共通スケール
      this.w = baseImg ? baseImg.width * scale : 48;
      this.h = baseImg ? baseImg.height* scale : CONFIG.playerLogicalH;
      // パラメータ（少し早め）
      this.moveSpeed = 360;
      this.maxVX = 520;
      this.jumpV = 700;
    }

    // 右前提スプライトを左移動時に反転表示
    drawSprite(name, shake=0){
      const img = IMGS[name];
      if (!img){
        ctx.fillStyle = '#fff'; ctx.fillRect(Math.round(this.x)+shake, Math.round(this.y)+shake, this.w, this.h);
        return;
      }
      const dw = Math.round(img.width * this.scale);
      const dh = Math.round(img.height* this.scale);
      // 更新（他の画像でも高さ基準に揃う）
      this.w = dw; this.h = dh;
      const dx = Math.round(this.x + shake);
      const dy = Math.round(this.y + shake);
      ctx.save();
      if (this.dir < 0){
        ctx.translate(dx + dw, dy);
        ctx.scale(-1, 1);
        ctx.drawImage(img, 0, 0, dw, dh);
      } else {
        ctx.drawImage(img, dx, dy, dw, dh);
      }
      ctx.restore();
    }

    currentSprite(){
      if (this.ulReleasing) return 'UL4.png';
      if (this.ulCharging){
        const seq = ['UL1.png','UL2.png','UL3.png'];
        return seq[Math.floor(this.animT*10)%seq.length];
      }
      if (this.atkPlaying){
        if (this.comboStep===1){
          const idx = Math.min(1, Math.floor(this.atkFrameT*12));
          return this.atk1[idx];
        } else if (this.comboStep===2){
          if (this.dashCharging) return 'kou.png';
          const idx = Math.min(1, Math.floor(this.atkFrameT*12));
          return this.atk2[idx];
        }
      }
      if (!this.onGround) return 'tati.png';
      const speed = Math.abs(this.vx);
      if (speed>20){
        const f = Math.floor(this.animT*CONFIG.runAnimFps) % this.runFrames.length;
        return this.runFrames[f];
      }
      return 'tati.png';
    }
  }

  // ====== Player / NPCs ======
  const player = new Actor(true, 300);
  const npcs = [];

  function spawnNPC(ix){
    // 適度にバラけた位置で右移動AI
    const a = new Actor(false, 600 + ix*220);
    a.y = 0;
    a.aiTimer = Math.random()*2;
    a.baseSpeed = 0.7 + Math.random()*0.6; // 個体差
    npcs.push(a);
  }
  for (let i=0;i<CONFIG.maxNPC;i++) spawnNPC(i);

  info.textContent = `${npcs.length} NPCs`;

  // ====== Projectiles（共有） ======
  const projectiles = [];
  function spawnULZan(actor, dir){
    const img = IMGS['ULzan.png'];
    const scale = actor.scale;
    const spd = 1100 * dir;
    const w = img ? Math.round(img.width * scale) : 48;
    const h = img ? Math.round(img.height* scale) : 16;
    projectiles.push({
      x: actor.x + actor.w/2 + dir*10,
      y: groundY() - h + 2,
      vx: spd,
      life: 3,
      w, h, scale, sprite:'ULzan.png'
    });
  }

  // ====== ULゲージ（プレイヤーのみHUD連動） ======
  function updateGauge(){
    const g = player.ulCharging ? (player.ulCharge/CONFIG.ulChargeMax) : 0;
    gfill.style.width = Math.round(Math.min(1,g)*100)+'%';
  }

  // ====== Game Loop ======
  let last = performance.now();
  requestAnimationFrame(loop);
  function loop(t){
    const dt = Math.min(0.033, (t-last)/1000); last = t;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // エッジ検出
  let prevAtk=false, prevUL=false;

  function update(dt){
    // ==== プレイヤー入力 ====
    const canControl = !player.ulReleasing && player.moveLock<=0;
    if (canControl){
      if (keys.has('Left'))  { player.vx -= player.moveSpeed*2*dt; player.dir=-1; }
      if (keys.has('Right')) { player.vx += player.moveSpeed*2*dt; player.dir= 1; }
      if (keys.has('Jump') && player.onGround){ player.vy = -player.jumpV; }
    }
    // 摩擦
    if (player.onGround && !(keys.has('Left')||keys.has('Right'))){
      const s = Math.sign(player.vx);
      const m = Math.min(Math.abs(player.vx), 1400*dt);
      player.vx -= s*m;
    }
    player.vx = clamp(player.vx, -player.maxVX, player.maxVX);

    // 重力・位置
    integrateActor(player, dt);

    // 攻撃処理（プレイヤー）
    handleAttack(player, dt, true);
    handleUL(player, dt, true);

    // ==== NPC AI ====
    for (const a of npcs){
      const speedMod = a.baseSpeed;
      if (!a.ulReleasing && a.moveLock<=0){
        a.vx += a.moveSpeed*2*dt*speedMod; // 基本右移動
        a.dir = 1;
        // たまにジャンプ
        a.aiTimer -= dt;
        if (a.aiTimer<=0){
          a.aiTimer = 1.2 + Math.random()*1.8;
          if (a.onGround && Math.random()<0.4) a.vy = -a.jumpV*(0.7 + Math.random()*0.4);
          // たまに攻撃1→2（短押し or 長押し）
          if (Math.random()<0.35) {
            startAttack1(a);
            if (Math.random()<0.7){ // 連撃する
              a.comboWindow = CONFIG.atkWindow;
              a.dashCharging = true;
              a.comboStep = 2;
              // ランダム長押し時間
              a.dashCharge = Math.random()*CONFIG.dashChargeMax;
              releaseAttack2Dash(a);
            }
          }
          // たまにUL
          if (!a.ulCharging && Math.random()<0.15){
            a.ulCharging = true; a.ulCharge = 0;
          }
        }
      }
      // ULチャージ続行
      if (a.ulCharging && !a.ulReleasing){
        a.ulCharge = Math.min(CONFIG.ulChargeMax, a.ulCharge + dt);
        if (a.ulCharge>=CONFIG.ulChargeMax && Math.random()<0.08){
          fireUL(a);
          a.ulCharging = false; a.ulCharge = 0;
        }
      }
      integrateActor(a, dt);
      handleAttack(a, dt, false);
      handleUL(a, dt, false);
    }

    // 弾
    for (let i=projectiles.length-1;i>=0;i--){
      const p = projectiles[i];
      p.x += p.vx*dt;
      p.y  = groundY() - p.h + 2;
      p.life -= dt;
      if (p.x<-200 || p.x>CONFIG.levelW+200 || p.life<=0) projectiles.splice(i,1);
    }

    // カメラ：プレイヤー中心
    camX = clamp(player.x + player.w*0.5 - W*0.45, 0, CONFIG.levelW - W);

    updateGauge();
  }

  function integrateActor(a, dt){
    a.animT += dt;
    if (a.moveLock>0) a.moveLock -= dt;
    // ダッシュ移動（2段目）
    if (a.dashInMotion){
      a.dashT -= dt;
      if (a.dashT<=0){
        a.dashInMotion = false;
        a.atkPlaying = false;
        a.comboStep = 0;
      }
    }
    // UL4中
    if (a.ulReleasing){
      a.ulLockT -= dt;
      if (a.ulLockT<=0) a.ulReleasing = false;
    }
    // 物理
    a.vy += CONFIG.gravity*dt;
    a.x  += a.vx*dt;
    a.y  += a.vy*dt;
    // 地面
    const gy = groundY();
    if (a.y + a.h > gy){ a.y = gy - a.h; a.vy=0; a.onGround=true; } else a.onGround=false;
    // 壁
    if (a.x < 0){ a.x=0; a.vx=0; }
    if (a.x + a.w > CONFIG.levelW){ a.x = CONFIG.levelW - a.w; a.vx=0; }
  }

  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }

  // ---- Attack (共通) ----
  function handleAttack(a, dt, isPlayer){
    const nowAtk = isPlayer ? keys.has('Attack') : false;
    if (a.comboWindow>0) a.comboWindow -= dt;
    if (a.atkPlaying) a.atkFrameT += dt;

    // プレイヤー：押下エッジで開始
    if (isPlayer){
      if (nowAtk && !prevAtk && !a.ulCharging && !a.ulReleasing){
        if (a.comboStep===0){
          startAttack1(a);
        } else if (a.comboStep===1 && a.comboWindow>0){
          startAttack2Prepare(a);
        }
      }
      // 離しエッジでダッシュ発動
      if (!nowAtk && prevAtk){
        if (a.comboStep===2 && a.dashCharging) releaseAttack2Dash(a);
      }
      prevAtk = nowAtk;
    }

    // 2段目チャージ継続（プレイヤーのみ長押し）
    if (a.comboStep===2 && a.dashCharging && isPlayer){
      a.dashCharge = clamp(a.dashCharge + dt, 0, CONFIG.dashChargeMax);
      a.vx *= 0.98;
    }
  }

  function startAttack1(a){
    a.atkPlaying = true;
    a.comboStep = 1;
    a.atkFrameT = 0;
    a.comboWindow = CONFIG.atkWindow;
    a.moveLock = 0.1;
  }

  function startAttack2Prepare(a){
    a.atkPlaying = true;
    a.comboStep = 2;
    a.atkFrameT = 0;
    a.dashCharging = true;
    a.dashCharge = 0;
    a.moveLock = 0.15;
  }

  function releaseAttack2Dash(a){
    a.dashCharging = false;
    a.dashInMotion = true;
    const ratio = clamp(a.dashCharge / CONFIG.dashChargeMax, 0, 1);
    const dashDist = 120 + ratio*240;
    const dashDur  = 0.16 + ratio*0.10;
    a.dashT = dashDur;
    const sign = a.dir<0 ? -1 : 1;
    const targetX = clamp(a.x + sign*dashDist, 0, CONFIG.levelW - a.w);
    const need = targetX - a.x;
    a.vx = need / dashDur;
    a.atkFrameT = 0; // kou2表示へ
  }

  // ---- UL（共通） ----
  function handleUL(a, dt, isPlayer){
    const nowUL = isPlayer ? keys.has('UL') : false;
    // プレイヤーのチャージ（長押し）
    if (isPlayer){
      if (nowUL && !a.ulReleasing){
        a.ulCharging = true;
        a.ulCharge = clamp(a.ulCharge + dt, 0, CONFIG.ulChargeMax);
        a.ulMaxBlink = (a.ulCharge >= CONFIG.ulChargeMax);
        a.atkPlaying = false; a.comboStep=0; a.dashCharging=false; a.dashInMotion=false;
      }
      if (!nowUL && prevUL){
        if (a.ulCharging && !a.ulReleasing){ fireUL(a); }
        a.ulCharging=false; a.ulCharge=0; a.ulMaxBlink=false;
      }
      prevUL = nowUL;
    }
  }

  function fireUL(a){
    a.ulReleasing = true;
    a.ulLockT = 2.0;
    spawnULZan(a, -1);
    spawnULZan(a, +1);
  }

  // ====== Render ======
  function render(){
    drawBackground();

    ctx.save();
    ctx.translate(-camX, 0);

    // 弾
    for (const p of projectiles){
      const img = IMGS[p.sprite];
      if (img){
        // ULzan もキャラスケールに合わせて拡大描画
        ctx.drawImage(img, Math.round(p.x), Math.round(p.y), p.w, p.h);
      }else{
        ctx.fillStyle='#7cf'; ctx.fillRect(p.x, p.y, p.w, p.h);
      }
    }

    // NPCs
    for (const a of npcs){
      const shake = a.ulReleasing ? (Math.random()*2-1)*2 : 0;
      a.drawSprite(a.currentSprite(), shake);
    }

    // Player
    {
      const a = player;
      const shake = a.ulReleasing ? (Math.random()*2-1)*2 : 0;
      a.drawSprite(a.currentSprite(), shake);

      // プレイヤーのみ頭上ゲージ
      if (a.ulCharging || a.ulReleasing){
        const g = a.ulCharging ? (a.ulCharge/CONFIG.ulChargeMax) : 0;
        const bw = 80, bh = 10;
        const gx = a.x + a.w/2 - bw/2;
        const gy = a.y - 18;
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.fillRect(gx-2, gy-2, bw+4, bh+4);
        ctx.fillStyle = '#203040'; ctx.fillRect(gx, gy, bw, bh);
        ctx.fillStyle = a.ulMaxBlink ? (Math.random()<0.5?'#8ff':'#fff') : '#7cf';
        ctx.fillRect(gx, gy, bw*g, bh);
        ctx.strokeStyle = '#5aa7ff'; ctx.strokeRect(gx, gy, bw, bh);
      }
    }

    ctx.restore();
  }
})();
</script>
</body>
</html>
